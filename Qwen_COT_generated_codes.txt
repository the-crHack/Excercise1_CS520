#####This file contains 5 variant of solutions (used for pass@k) for the each of the selected problem statement generated by Qwen using Chain of thought propting technique.


problem1_solutions = [
    """def position_max(lst):
    \"\"\"Find all index positions of the maximum values in a given list.\"\"\"
    if not lst:
        return []
    max_val = max(lst)
    return [i for i, val in enumerate(lst) if val == max_val]""",

    """def position_max(lst):
    \"\"\"Find all index positions of the maximum values in a given list.\"\"\"
    if not lst:
        return []
    max_val = max(lst)
    return [i for i, x in enumerate(lst) if x == max_val]""",

    """def position_max(lst):
    if not lst:
        return []
    max_val = max(lst)
    return [i for i, x in enumerate(lst) if x == max_val]""",

    """def position_max(lst):
    if not lst:
        return []
    m = max(lst)
    return [i for i, v in enumerate(lst) if v == m]""",
]

problem2_solutions = [
    """def find_Diff(arr):
    \"\"\"Find the difference between highest and least frequencies in a given array.\"\"\"
    if not arr:
        return 0
    from collections import Counter
    freq = Counter(arr)
    frequencies = list(freq.values())
    return max(frequencies) - min(frequencies)""",

    """def find_Diff(arr):
    \"\"\"Find the difference between highest and least frequencies in a given array.\"\"\"
    if not arr:
        return 0
    from collections import Counter
    freq = Counter(arr)
    frequencies = list(freq.values())
    return max(frequencies) - min(frequencies)""",

    """def find_Diff(arr):
    if not arr:
        return 0
    from collections import Counter
    freq = Counter(arr)
    frequencies = list(freq.values())
    return max(frequencies) - min(frequencies)""",

    """def find_Diff(arr):
    if not arr:
        return 0
    from collections import Counter
    c = Counter(arr).values()
    return max(c) - min(c)""",
]

problem3_solutions = [
    """def is_valid_parenthese(s):
    \"\"\"Verify validity of a string of parentheses.\"\"\"
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in mapping.values():
            stack.append(char)
        elif char in mapping:
            if not stack or stack.pop() != mapping[char]:
                return False
    return not stack""",

    """def is_valid_parenthese(s):
    \"\"\"Verify validity of a string of parentheses.\"\"\"
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in mapping.values():
            stack.append(char)
        elif char in mapping:
            if not stack or stack.pop() != mapping[char]:
                return False
    return not stack""",

    """def is_valid_parenthese(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in mapping.values():
            stack.append(char)
        elif char in mapping:
            if not stack or stack.pop() != mapping[char]:
                return False
    return not stack""",

    """def is_valid_parenthese(s):
    d = {'(': ')', '[': ']', '{': '}'}
    stack = []
    for ch in s:
        if ch in d:
            stack.append(ch)
        elif not stack or d[stack.pop()] != ch:
            return False
    return not stack""",
]

problem4_solutions = [
    """def find_peak(arr):
    \"\"\"Find a peak element in the given array (an element greater than its neighbors).\"\"\"
    if not arr:
        return None
    n = len(arr)
    if n == 1:
        return arr[0]
    if arr[0] > arr[1]:
        return arr[0]
    if arr[n - 1] > arr[n - 2]:
        return arr[n - 1]
    for i in range(1, n - 1):
        if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:
            return arr[i]
    # In case no peak found (shouldn't happen in typical cases with distinct neighbors),
    # return the maximum as fallback
    return max(arr)""",

    """def find_peak(arr):
    \"\"\"Find a peak element in the given array (an element greater than its neighbors).\"\"\"
    if not arr:
        return None
    n = len(arr)
    if n == 1:
        return arr[0]
    if arr[0] > arr[1]:
        return arr[0]
    if arr[n - 1] > arr[n - 2]:
        return arr[n - 1]
    for i in range(1, n - 1):
        if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]:
            return arr[i]
    # In case all elements are equal, return any (e.g., first)
    return arr[0]""",

    """def find_peak(arr):
    if not arr:
        return None
    n = len(arr)
    if n == 1:
        return arr[0]
    if arr[0] >= arr[1]:
        return arr[0]
    if arr[n - 1] >= arr[n - 2]:
        return arr[n - 1]
    for i in range(1, n - 1):
        if arr[i] >= arr[i - 1] and arr[i] >= arr[i + 1]:
            return arr[i]
    return arr[0]  # fallback (should not be needed for valid inputs)""",

    """def find_peak(arr):
    if len(arr) == 1:
        return arr[0]
    for i in range(len(arr)):
        left = arr[i - 1] if i > 0 else float('-inf')
        right = arr[i + 1] if i < len(arr) - 1 else float('-inf')
        if arr[i] > left and arr[i] > right:
            return arr[i]
    return arr[0]""",
]

problem5_solutions = [
    """def bell_number(n):
    \"\"\"Return the nth Bell number (number of ways to partition a set of n elements).\"\"\"
    if n < 0:
        return 0
    if n == 0:
        return 1
    # Use Bell triangle method
    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]
    bell[0][0] = 1
    for i in range(1, n + 1):
        bell[i][0] = bell[i - 1][i - 1]
        for j in range(1, i + 1):
            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]
    return bell[n][0]""",

    """def bell_number(n):
    \"\"\"Return the nth Bell number (number of ways to partition a set of n elements).\"\"\"
    if n < 0:
        return 0
    if n == 0:
        return 1
    # Bell triangle method
    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]
    bell[0][0] = 1
    for i in range(1, n + 1):
        bell[i][0] = bell[i - 1][i - 1]
        for j in range(1, i + 1):
            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]
    return bell[n][0]""",

    """def bell_number(n):
    if n < 0:
        return 0
    if n == 0:
        return 1
    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]
    bell[0][0] = 1
    for i in range(1, n + 1):
        bell[i][0] = bell[i - 1][i - 1]
        for j in range(1, i + 1):
            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]
    return bell[n][0]""",

    """def bell_number(n):
    if n < 0:
        return 0
    bell = [[0] * (n + 1) for _ in range(n + 1)]
    bell[0][0] = 1
    for i in range(1, n + 1):
        bell[i][0] = bell[i - 1][i - 1]
        for j in range(1, i + 1):
            bell[i][j] = bell[i][j - 1] + bell[i - 1][j - 1]
    return bell[n][0]""",
]

problem6_solutions = [
    """def filter_oddnumbers(nums):
    \"\"\"Filter odd numbers using lambda function.\"\"\"
    return list(filter(lambda x: x % 2 != 0, nums))""",

    """def filter_oddnumbers(nums):
    \"\"\"Filter odd numbers using lambda function.\"\"\"
    return list(filter(lambda x: x % 2 != 0, nums))""",

    """def filter_oddnumbers(nums):
    return list(filter(lambda x: x % 2 != 0, nums))""",

    """def filter_oddnumbers(lst):
    return list(filter(lambda x: x % 2 != 0, lst))""",
]

problem7_solutions = [
    """def bitwise_xor(tup1, tup2):
    \"\"\"Perform bitwise XOR operation across the given tuples element-wise.\"\"\"
    return tuple(a ^ b for a, b in zip(tup1, tup2))""",

    """def bitwise_xor(tup1, tup2):
    \"\"\"Perform bitwise XOR operation across the given tuples element-wise.\"\"\"
    return tuple(a ^ b for a, b in zip(tup1, tup2))""",

    """def bitwise_xor(tup1, tup2):
    return tuple(a ^ b for a, b in zip(tup1, tup2))""",
]

problem8_solutions = [
    """def count_Squares(m, n):
    \"\"\"Count the number of squares in a m x n rectangle.\"\"\"
    if m <= 0 or n <= 0:
        return 0
    total = 0
    min_side = min(m, n)
    for i in range(1, min_side + 1):
        total += (m - i + 1) * (n - i + 1)
    return total""",

    """def count_Squares(m, n):
    \"\"\"Count the number of squares in a m x n rectangle.\"\"\"
    if m <= 0 or n <= 0:
        return 0
    total = 0
    min_side = min(m, n)
    for i in range(1, min_side + 1):
        total += (m - i + 1) * (n - i + 1)
    return total""",

    """def count_Squares(m, n):
    if m <= 0 or n <= 0:
        return 0
    return sum((m - i) * (n - i) for i in range(min(m, n)))""",

    """def count_Squares(m, n):
    return sum(min(i, j) for i in range(1, m + 1) for j in range(1, n + 1))""",
]

problem9_solutions = [
    """def sub_list(list1, list2):
    \"\"\"Subtract two lists element-wise using map and lambda function.\"\"\"
    return list(map(lambda x, y: x - y, list1, list2))""",

    """def sub_list(list1, list2):
    \"\"\"Subtract two lists element-wise using map and lambda function.\"\"\"
    return list(map(lambda x, y: x - y, list1, list2))""",

    """def sub_list(list1, list2):
    return list(map(lambda x, y: x - y, list1, list2))""",
]

problem10_solutions = [
    """def month_season(month, day):
    \"\"\"Return the season for the given month and day (Northern Hemisphere).\"\"\"
    if month in [1, 2] or (month == 3 and day < 20) or (month == 12 and day >= 21):
        return "Winter"
    elif month in [4, 5] or (month == 3 and day >= 20) or (month == 6 and day < 21):
        return "Spring"
    elif month in [7, 8] or (month == 6 and day >= 21) or (month == 9 and day < 22):
        return "Summer"
    elif month in [10, 11] or (month == 9 and day >= 22) or (month == 12 and day < 21):
        return "Autumn"
    else:
        return "Invalid date\"""",

    """def month_season(month, day):
    \"\"\"Return the season for the given month and day (Northern Hemisphere).\"\"\"
    if month in [12, 1, 2]:
        if month == 12 and day >= 21:
            return "Winter"
        elif month == 3 and day < 20:
            return "Winter"
        elif month in [1, 2]:
            return "Winter"
    if month in [3, 4, 5]:
        if month == 3 and day >= 20:
            return "Spring"
        elif month == 6 and day < 21:
            return "Spring"
        elif month in [4, 5]:
            return "Spring"
    if month in [6, 7, 8]:
        if month == 6 and day >= 21:
            return "Summer"
        elif month == 9 and day < 22:
            return "Summer"
        elif month in [7, 8]:
            return "Summer"
    if month in [9, 10, 11]:
        if month == 9 and day >= 22:
            return "Autumn"
        elif month == 12 and day < 21:
            return "Autumn"
        elif month in [10, 11]:
            return "Autumn"
    # Fallback for edge cases
    if month == 12 and day < 21:
        return "Autumn"
    if month == 3 and day < 20:
        return "Winter"
    if month == 6 and day < 21:
        return "Spring"
    if month == 9 and day < 22:
        return "Summer"
    return "Invalid\"""",

    """def month_season(month, day):
    if not (1 <= month <= 12) or not (1 <= day <= 31):
        return "Invalid date"
    
    # Normalize month and day for season calculation
    if month == 12 and day >= 21:
        return "Winter"
    elif month in [1, 2] or (month == 3 and day < 20):
        return "Winter"
    elif month in [3, 4, 5] or (month == 6 and day < 21):
        if month == 3 and day >= 20:
            return "Spring"
        elif month == 6 and day < 21:
            return "Spring"
        else:
            return "Spring"
    elif month in [6, 7, 8] or (month == 9 and day < 22):
        if month == 6 and day >= 21:
            return "Summer"
        elif month == 9 and day < 22:
            return "Summer"
        else:
            return "Summer"
    elif month in [9, 10, 11] or (month == 12 and day < 21):
        if month == 9 and day >= 22:
            return "Autumn"
        elif month == 12 and day < 21:
            return "Autumn"
        else:
            return "Autumn"
    else:
        return "Winter\"""",

    """def month_season(month, day):
    if month in [12, 1, 2]:
        if (month == 12 and day >= 21) or (month == 3 and day <= 19):
            return "Winter"
        elif month == 1 or month == 2:
            return "Winter"
    if month in [3, 4, 5]:
        if (month == 3 and day >= 20) or (month == 6 and day <= 20):
            return "Spring"
        elif month == 4 or month == 5:
            return "Spring"
    if month in [6, 7, 8]:
        if (month == 6 and day >= 21) or (month == 9 and day <= 21):
            return "Summer"
        elif month == 7 or month == 8:
            return "Summer"
    if month in [9, 10, 11]:
        if (month == 9 and day >= 22) or (month == 12 and day <= 20):
            return "Autumn"
        elif month == 10 or month == 11:
            return "Autumn"
    # Fallback for edge cases
    if month == 12 and day >= 21:
        return "Winter"
    if month == 3 and day >= 20:
        return "Spring"
    if month == 6 and day >= 21:
        return "Summer"
    if month == 9 and day >= 22:
        return "Autumn"
    return "Invalid\"""",
]
