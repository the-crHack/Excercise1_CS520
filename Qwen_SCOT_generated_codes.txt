#####This file contains 5 variant of solutions(used for pass@k) for each of the problem statement generated by Qwen using step wise Chain of thought propting technique.

problem1_solutions = [
    """def position_max(lst):
    if not lst:
        return []
    max_val = max(lst)
    return [i for i, x in enumerate(lst) if x == max_val]""",

    """def position_max(lst):
    if not lst:
        return []
    m = max(lst)
    return [i for i, v in enumerate(lst) if v == m]""",

    """def position_max(lst):
    return [i for i, x in enumerate(lst) if x == max(lst)] if lst else []""",

    """def position_max(lst):
    if not lst:
        return []
    mx = lst[0]
    for x in lst[1:]:
        if x > mx:
            mx = x
    return [i for i, x in enumerate(lst) if x == mx]""",

    """def position_max(lst):
    return [i for i, val in enumerate(lst) if val == max(lst)] if lst else []""",
]

problem2_solutions = [
    """def find_Diff(arr):
    if not arr:
        return 0
    freq = Counter(arr)
    frequencies = list(freq.values())
    return max(frequencies) - min(frequencies)""",

    """def find_Diff(arr):
    if not arr:
        return 0
    freqs = Counter(arr).values()
    return max(freqs) - min(freqs)""",

    """def find_Diff(arr):
    if not arr:
        return 0
    c = Counter(arr)
    vals = c.values()
    return max(vals) - min(vals)""",

    """def find_Diff(arr):
    if not arr:
        return 0
    f = Counter(arr)
    return max(f.values()) - min(f.values())""",

    """def find_Diff(arr):
    if not arr:
        return 0
    c = Counter(arr)
    freqs = list(c.values())
    return max(freqs) - min(freqs)""",
]

problem3_solutions = [
    """def is_valid_parenthese(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in mapping.values():
            stack.append(char)
        elif char in mapping:
            if not stack or stack.pop() != mapping[char]:
                return False
        else:
            # If the character is not a parenthesis, treat as invalid
            return False
    return not stack""",

    """def is_valid_parenthese(s):
    stack = []
    pairs = {'(': ')', '[': ']', '{': '}'}
    for c in s:
        if c in pairs:
            stack.append(c)
        elif c in pairs.values():
            if not stack or pairs[stack.pop()] != c:
                return False
        else:
            return False
    return len(stack) == 0""",

    """def is_valid_parenthese(s):
    balance = {'(': 0, '[': 0, '{': 0}
    stack = []
    for ch in s:
        if ch in '([{':
            stack.append(ch)
            balance[ch] += 1
        elif ch == ')':
            if not stack or stack.pop() != '(':
                return False
        elif ch == ']':
            if not stack or stack.pop() != '[':
                return False
        elif ch == '}':
            if not stack or stack.pop() != '{':
                return False
        else:
            return False
    return not stack""",

    """def is_valid_parenthese(s):
    stack = []
    for c in s:
        if c in '([{':
            stack.append(c)
        elif c == ')':
            if not stack or stack[-1] != '(':
                return False
            stack.pop()
        elif c == ']':
            if not stack or stack[-1] != '[':
                return False
            stack.pop()
        elif c == '}':
            if not stack or stack[-1] != '{':
                return False
            stack.pop()
        else:
            return False
    return len(stack) == 0""",

    """def is_valid_parenthese(s):
    mapping = {')': '(', ']': '[', '}': '{'}
    stack = []
    for char in s:
        if char in mapping.values():
            stack.append(char)
        elif char in mapping:
            if not stack or stack.pop() != mapping[char]:
                return False
        else:
            return False
    return not stack""",
]

problem4_solutions = [
    """def find_peak(arr):
    if not arr:
        return None
    n = len(arr)
    if n == 1:
        return arr[0]
    if arr[0] > arr[1]:
        return arr[0]
    if arr[-1] > arr[-2]:
        return arr[-1]
    for i in range(1, n - 1):
        if arr[i] >= arr[i - 1] and arr[i] >= arr[i + 1]:
            return arr[i]
    # Fallback (should not happen in valid peak problems, but safe)
    return max(arr)""",

    """def find_peak(arr):
    if not arr:
        return None
    n = len(arr)
    for i in range(n):
        left = arr[i - 1] if i > 0 else float('-inf')
        right = arr[i + 1] if i < n - 1 else float('-inf')
        if arr[i] >= left and arr[i] >= right:
            return arr[i]
    return arr[0]""",

    """def find_peak(arr):
    if not arr:
        return None
    if len(arr) == 1:
        return arr[0]
    if arr[0] >= arr[1]:
        return arr[0]
    if arr[-1] >= arr[-2]:
        return arr[-1]
    for i in range(1, len(arr) - 1):
        if arr[i] >= arr[i-1] and arr[i] >= arr[i+1]:
            return arr[i]
    return max(arr)""",

    """def find_peak(arr):
    if not arr:
        return None
    n = len(arr)
    low, high = 0, n - 1
    while low <= high:
        mid = (low + high) // 2
        left = arr[mid - 1] if mid > 0 else float('-inf')
        right = arr[mid + 1] if mid < n - 1 else float('-inf')
        if arr[mid] >= left and arr[mid] >= right:
            return arr[mid]
        if left > arr[mid]:
            high = mid - 1
        else:
            low = mid + 1
    return arr[0]""",

    """def find_peak(arr):
    if not arr:
        return None
    for i in range(len(arr)):
        is_peak = True
        if i > 0 and arr[i] < arr[i - 1]:
            is_peak = False
        if i < len(arr) - 1 and arr[i] < arr[i + 1]:
            is_peak = False
        if is_peak:
            return arr[i]
    return arr[0]""",
]

problem5_solutions = [
    """def bell_number(n):
    if n < 0:
        return 0
    if n == 0:
        return 1
    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]
    bell[0][0] = 1
    for i in range(1, n + 1):
        bell[i][0] = bell[i - 1][i - 1]
        for j in range(1, i + 1):
            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]
    return bell[n][0]""",

    """def bell_number(n):
    if n < 0:
        return 0
    if n == 0:
        return 1
    bell = [0] * (n + 1)
    bell[0] = 1
    for i in range(1, n + 1):
        bell[i] = 0
        for k in range(i):
            bell[i] += comb(i - 1, k) * bell[k]
    return bell[n]""",

    """def bell_number(n):
    if n == 0:
        return 1
    if n < 0:
        return 0
    dp = [[0] * (n + 1) for _ in range(n + 1)]
    dp[0][0] = 1
    for i in range(1, n + 1):
        dp[i][0] = dp[i-1][i-1]
        for j in range(1, i + 1):
            dp[i][j] = dp[i-1][j-1] + dp[i][j-1]
    return dp[n][0]""",

    """def bell_number(n):
    if n < 0:
        return 0
    if n == 0:
        return 1
    bell_prev = [1]
    for i in range(1, n + 1):
        bell_curr = [bell_prev[-1]]
        for j in range(1, i + 1):
            bell_curr.append(bell_curr[j - 1] + bell_prev[j - 1])
        bell_prev = bell_curr
    return bell_prev[0]""",

    """def bell_number(n):
    if n == 0:
        return 1
    if n < 0:
        return 0
    T = [[0] * (n + 1) for _ in range(n + 1)]
    T[0][0] = 1
    for i in range(1, n + 1):
        T[i][0] = T[i - 1][i - 1]
        for j in range(1, i + 1):
            T[i][j] = T[i - 1][j - 1] + T[i][j - 1]
    return T[n][0]""",
]

problem6_solutions = [
    """def filter_oddnumbers(nums):
    return list(filter(lambda x: x % 2 != 0, nums))""",

    """def filter_oddnumbers(nums):
    return list(filter(lambda x: x & 1, nums))""",

    """def filter_oddnumbers(nums):
    return list(filter(lambda x: x % 2 == 1, nums))""",

    """def filter_oddnumbers(nums):
    return [x for x in nums if x % 2 != 0]""",

    """def filter_oddnumbers(nums):
    return list(filter(lambda x: x % 2, nums))""",
]

problem7_solutions = [
    """def bitwise_xor(tup1, tup2):
    if len(tup1) != len(tup2):
        raise ValueError("Tuples must be of the same length")
    return tuple(a ^ b for a, b in zip(tup1, tup2))""",

    """def bitwise_xor(t1, t2):
    if len(t1) != len(t2):
        raise ValueError
    return tuple(a ^ b for a, b in zip(t1, t2))""",

    """def bitwise_xor(t1, t2):
    return tuple(a ^ b for a, b in zip(t1, t2))""",

    """def bitwise_xor(t1, t2):
    if len(t1) != len(t2):
        raise Exception("Length mismatch")
    out = []
    for a, b in zip(t1, t2):
        out.append(a ^ b)
    return tuple(out)""",

    """def bitwise_xor(t1, t2):
    return tuple(map(lambda a, b: a ^ b, t1, t2))""",
]

problem8_solutions = [
    """def count_Squares(m, n):
    # Count total number of squares in m x n rectangle
    if m <= 0 or n <= 0:
        return 0
    min_side = min(m, n)
    total = 0
    for k in range(1, min_side + 1):
        total += (m - k + 1) * (n - k + 1)
    return total""",

    """def count_Squares(m, n):
    if m <= 0 or n <= 0:
        return 0
    return sum((m - k + 1) * (n - k + 1) for k in range(1, min(m, n) + 1))""",

    """def count_Squares(m, n):
    total = 0
    for size in range(1, min(m, n) + 1):
        total += (m - size + 1) * (n - size + 1)
    return total""",

    """def count_Squares(m, n):
    if m <= 0 or n <= 0:
        return 0
    s = 0
    k = 1
    while k <= m and k <= n:
        s += (m - k + 1) * (n - k + 1)
        k += 1
    return s""",

    """def count_Squares(m, n):
    total = 0
    for k in range(1, min(m, n) + 1):
        total += (m - k + 1) * (n - k + 1)
    return total""",
]

problem9_solutions = [
    """def sub_list(list1, list2):
    if len(list1) != len(list2):
        raise ValueError("Lists must be of the same length")
    return list(map(lambda x, y: x - y, list1, list2))""",

    """def sub_list(l1, l2):
    if len(l1) != len(l2):
        raise ValueError
    return list(map(lambda x, y: x - y, l1, l2))""",

    """def sub_list(a, b):
    return [x - y for x, y in zip(a, b)]""",

    """def sub_list(l1, l2):
    return [a - b for a, b in zip(l1, l2)]""",

    """def sub_list(a, b):
    return list(map(lambda x, y: x - y, a, b))""",
]

problem10_solutions = [
    """def month_season(month, day):
    if not (1 <= month <= 12) or not (1 <= day <= 31):
        return "Invalid date"
    if month in [12, 1, 2]:
        if (month == 12 and day >= 21) or (month in [1, 2]) or (month == 3 and day < 20):
            return "Winter"
    if month in [3, 4, 5]:
        if (month == 3 and day >= 20) or (month in [4, 5]) or (month == 6 and day < 21):
            return "Spring"
    if month in [6, 7, 8]:
        if (month == 6 and day >= 21) or (month in [7, 8]) or (month == 9 and day < 22):
            return "Summer"
    if month in [9, 10, 11]:
        if (month == 9 and day >= 22) or (month in [10, 11]) or (month == 12 and day < 21):
            return "Autumn"
    if month == 3 and day < 20:
        return "Winter"
    if month == 6 and day < 21:
        return "Spring"
    if month == 9 and day < 22:
        return "Summer"
    if month == 12 and day < 21:
        return "Autumn"
    return "Invalid date\"""",

    """def month_season(month, day):
    if not (1 <= month <= 12 and 1 <= day <= 31):
        return "Invalid date"
    if (month == 12 and day >= 21) or month in (1, 2) or (month == 3 and day < 20):
        return "Winter"
    if (month == 3 and day >= 20) or month in (4, 5) or (month == 6 and day < 21):
        return "Spring"
    if (month == 6 and day >= 21) or month in (7, 8) or (month == 9 and day < 22):
        return "Summer"
    if (month == 9 and day >= 22) or month in (10, 11) or (month == 12 and day < 21):
        return "Autumn"
    return "Invalid date\"""",

    """def month_season(month, day):
    if month < 1 or month > 12 or day < 1 or day > 31:
        return "Invalid date"
    if month in [1, 2] or (month == 12 and day >= 21) or (month == 3 and day < 20):
        return "Winter"
    if month in [4, 5] or (month == 3 and day >= 20) or (month == 6 and day < 21):
        return "Spring"
    if month in [7, 8] or (month == 6 and day >= 21) or (month == 9 and day < 22):
        return "Summer"
    if month in [10, 11] or (month == 9 and day >= 22) or (month == 12 and day < 21):
        return "Autumn"
    return "Invalid date\"""",

    """def month_season(month, day):
    if not (1 <= month <= 12 and 1 <= day <= 31):
        return "Invalid date"
    seasons = [
        (3, 20, "Spring"),
        (6, 21, "Summer"),
        (9, 22, "Autumn"),
        (12, 21, "Winter")
    ]
    year_day = 0
    days_in_month = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    for i in range(month - 1):
        year_day += days_in_month[i]
    year_day += day
    cutoffs = [(80, "Spring"), (172, "Summer"), (264, "Autumn"), (355, "Winter")]
    if year_day < 80:
        return "Winter"
    elif year_day < 172:
        return "Spring"
    elif year_day < 264:
        return "Summer"
    elif year_day < 355:
        return "Autumn"
    else:
        return "Winter\"""",

    """def month_season(month, day):
    if month not in range(1, 13) or day not in range(1, 32):
        return "Invalid date"
    if month == 12:
        return "Winter" if day >= 21 else "Autumn"
    if month == 3:
        return "Spring" if day >= 20 else "Winter"
    if month == 6:
        return "Summer" if day >= 21 else "Spring"
    if month == 9:
        return "Autumn" if day >= 22 else "Summer"
    if month in [1, 2]:
        return "Winter"
    if month in [4, 5]:
        return "Spring"
    if month in [7, 8]:
        return "Summer"
    if month in [10, 11]:
        return "Autumn"
    return "Invalid date\"""",
]
